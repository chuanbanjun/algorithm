'''
有一个非常经典的概率问题，是一个袋子里面有若干个红球和若干个蓝球，
两个人轮流取出一个球，谁先取到红球谁就赢了，当人的先后顺序和球的数量确定时，
双方的胜率都可以由计算得到，这个问题显然是很简单的。

现在有一个进阶版的问题，同样是一个袋子里面有n个红球和m个蓝球，
共有A，B，C三人参与游戏，三人按照A，B，C的顺序轮流操作，在每一回合中，
A，B，C都会随机从袋子里面拿走一个球，然而真正分出胜负的只有A，B两个人，
没错，C就是来捣乱的，他除了可以使得袋子里面减少一个球，没有其他任何意义，
而A，B谁 先拿到红球就可以获得胜利，但是由于C的存在，两人可能都拿不到红球，
此时B获得胜利。
'''



def solution(n,m):
    dp = [[0]*max(m+1,3) for _ in range(max(n+1,2))]

    for i in range(n+1):
        dp[i][1] = i / (i + 1)
    dp[1][2] = 1 / 3
    for i in range(2, n):
        dp[i][2] = i / (2 + i) + (2 / ((2 + i) * (1 + i)))

    for i in range(n+1):
        for j in range(3, m+1):
            dp[i][j] = i / (i + j) + (j / (i + j)) * ((j - 1) / (i + j - 1)) * (
                        (i / (i + j - 2)) * dp[i - 1][j - 2] + ((j - 2) / (i + j - 2)) * dp[i][j - 3])

    return "%.5f" % dp[n][m]


if __name__ == '__main__':

    n,m = input().split()
    print(solution(int(n), int(m)))